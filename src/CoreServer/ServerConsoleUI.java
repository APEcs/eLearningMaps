package CoreServer;

import elearningmaps.User;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.URL;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.StringTokenizer;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;


/*******************************************************************************
 * ServerConsoleUI.java
 *
 *
 * This class will be called by the ServerComponent class and it will be
 * responsible for generating the GUI for the server component of eLearningMaps.
 * GUI will consists of all commands needed to control the server part of the
 * application. It will consist of :
 *      (1) A log of all messages
 *      (2) A console that will accept commands from the client.
 *
 * @author Klitos Christodoulou
 * Created on 02-Jun-2010, 14:48:22
 ******************************************************************************/

public class ServerConsoleUI extends javax.swing.JFrame {
 
 /*******************************************************************
 * Variable declaration
 */
 private ServerMessages msg = new ServerMessages(); /*Get messages from this*/
 private long startTime;
 private javax.swing.Timer upTimeCounter;
 private final static String newLine = "\n";  /*This will be used to change line
                                               when new text in textArea*/
 private ServerAcceptThread whileThread= null; /*This is the thread that will listen to
                                                multiple requests. It has the while loop*/

 /*This object will hold the serverSocket that will listen on a specific port.
  Port and server can be specified by the textfields in the GUI*/
 private ServerSocket serverSocket = null;

 /*Hold a reference to ServerEncryption Class*/
 private ServerEncryption servEncytptMechanism = null;

 /*Variable used in the while loop. The serve will keep listening*/
 boolean listening = true;

 /*A reference to ServerFileReader - read the xml file*/
 private ServerFileReader file_reader = null;
 private File fileName = null; /*default is clients_db.xml*/
 private List existingClientsList;  /*List will contain all the register users*/

 /*Boolean set to true when server starts once*/
 private boolean startOnce = false;

  /*********************************************************************
  * SERVERCONSOLE CLASS: The constructor method will call initComponents
  * to initialize the components on the form.
  */
  public ServerConsoleUI() {
    initComponents();

    /*Place JFrame in the middle of the screen*/
    this.setLocationRelativeTo(null);

    /*Replace window listener*/
    this.addWindowListener(new WindowAdapter()
    {
      public void windowClosing( WindowEvent event) {
       quitMethod();
      }//end WindowEvent
    });//end WindowListener

    /*Instantiate ServerEncryption Class*/
    servEncytptMechanism = new ServerEncryption();

    /*Read mail Server details from email.dat*/
    readMailServerFile();

    /*Hold a reference to ServerFileReader. Used to read clients_db xml*/
    file_reader = new ServerFileReader(null);
    fileName = new File("clients_db.dat");

    /*Store the list with existing users*/
    existingClientsList = Collections.synchronizedList(new ArrayList());

    /*Set hostname and port to the default*/
    hostNameTxt.setText("localhost");

    //Tested with port 4444
    hostPortTxt.setText("3830");
  }//end constructor

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    serverTabbedPane = new javax.swing.JTabbedPane();
    homeTabPanel = new javax.swing.JPanel();
    jPanel2 = new javax.swing.JPanel();
    serverNameLbl = new javax.swing.JLabel();
    hostNameTxt = new javax.swing.JTextField();
    hostPortLbl = new javax.swing.JLabel();
    hostPortTxt = new javax.swing.JTextField();
    exitBtn = new javax.swing.JButton();
    startServerBtn = new javax.swing.JToggleButton();
    jLabel2 = new javax.swing.JLabel();
    upTimeLbl = new javax.swing.JLabel();
    publicIPbox = new javax.swing.JCheckBox();
    jScrollPane1 = new javax.swing.JScrollPane();
    logTextArea = new javax.swing.JTextArea();
    saveLogBtn = new javax.swing.JButton();
    jLabel1 = new javax.swing.JLabel();
    settingsTabPanel = new javax.swing.JPanel();
    loadBtn = new javax.swing.JPanel();
    jLabel3 = new javax.swing.JLabel();
    saveButton = new javax.swing.JButton();
    jLabel4 = new javax.swing.JLabel();
    loadButton = new javax.swing.JButton();
    settiingsPanel = new javax.swing.JPanel();
    jPanel1 = new javax.swing.JPanel();
    protocolLbl = new javax.swing.JLabel();
    MhostLbl = new javax.swing.JLabel();
    MuserLbl = new javax.swing.JLabel();
    jLabel5 = new javax.swing.JLabel();
    protocolCbox = new javax.swing.JComboBox();
    mailHostTxt = new javax.swing.JTextField();
    mailUserHost = new javax.swing.JTextField();
    mailPassHost = new javax.swing.JPasswordField();
    jLabel6 = new javax.swing.JLabel();
    mailPortTxt = new javax.swing.JTextField();
    jLabel7 = new javax.swing.JLabel();
    mailAddressTxt = new javax.swing.JTextField();

    setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
    setTitle("eLearningMaps - Server Console");
    setLocationByPlatform(true);
    setResizable(false);

    jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

    serverNameLbl.setText("Host Name:");

    hostNameTxt.setEditable(false);
    hostNameTxt.setToolTipText("Server IP");

    hostPortLbl.setText("Host Port:");

    exitBtn.setText("EXIT");
    exitBtn.setToolTipText("exit / shutdown server");
    exitBtn.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        exitBtnActionPerformed(evt);
      }
    });

    startServerBtn.setText("GO!");
    startServerBtn.setToolTipText("on/off server");
    startServerBtn.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        startServerBtnActionPerformed(evt);
      }
    });

    jLabel2.setFont(new java.awt.Font("Tahoma", 1, 11));
    jLabel2.setText("Up Time:");

    upTimeLbl.setFont(new java.awt.Font("Tahoma", 1, 11));
    upTimeLbl.setText("0:00:00");

    publicIPbox.setText("Use non-local IP Address");
    publicIPbox.setToolTipText("Use public IP");

    javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
    jPanel2.setLayout(jPanel2Layout);
    jPanel2Layout.setHorizontalGroup(
      jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel2Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(jPanel2Layout.createSequentialGroup()
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(serverNameLbl)
              .addComponent(hostPortLbl))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(hostNameTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE)
              .addComponent(hostPortTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 57, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 160, Short.MAX_VALUE)
            .addComponent(startServerBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 72, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(exitBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
            .addContainerGap())
          .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
            .addComponent(jLabel2)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(upTimeLbl)
            .addGap(200, 200, 200))
          .addGroup(jPanel2Layout.createSequentialGroup()
            .addComponent(publicIPbox)
            .addContainerGap(337, Short.MAX_VALUE))))
    );
    jPanel2Layout.setVerticalGroup(
      jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel2Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
          .addGroup(jPanel2Layout.createSequentialGroup()
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
              .addComponent(serverNameLbl)
              .addComponent(hostNameTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
              .addComponent(hostPortLbl)
              .addComponent(hostPortTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(publicIPbox)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
              .addComponent(jLabel2)
              .addComponent(upTimeLbl))
            .addContainerGap())
          .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
            .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
              .addComponent(startServerBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
              .addComponent(exitBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGap(70, 70, 70))))
    );

    jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    jScrollPane1.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

    logTextArea.setColumns(20);
    logTextArea.setEditable(false);
    logTextArea.setFont(new java.awt.Font("Tahoma", 0, 11));
    logTextArea.setRows(5);
    logTextArea.setToolTipText("Server Log ");
    jScrollPane1.setViewportView(logTextArea);

    saveLogBtn.setText("Save Log");

    jLabel1.setText("eLearningMaps - ServerConsole");
    jLabel1.setEnabled(false);

    javax.swing.GroupLayout homeTabPanelLayout = new javax.swing.GroupLayout(homeTabPanel);
    homeTabPanel.setLayout(homeTabPanelLayout);
    homeTabPanelLayout.setHorizontalGroup(
      homeTabPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, homeTabPanelLayout.createSequentialGroup()
        .addContainerGap()
        .addGroup(homeTabPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
          .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 496, Short.MAX_VALUE)
          .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
          .addGroup(homeTabPanelLayout.createSequentialGroup()
            .addComponent(jLabel1)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 267, Short.MAX_VALUE)
            .addComponent(saveLogBtn)))
        .addContainerGap())
    );
    homeTabPanelLayout.setVerticalGroup(
      homeTabPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, homeTabPanelLayout.createSequentialGroup()
        .addContainerGap()
        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addGap(18, 18, 18)
        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 138, Short.MAX_VALUE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(homeTabPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
          .addComponent(saveLogBtn)
          .addComponent(jLabel1))
        .addGap(12, 12, 12))
    );

    serverTabbedPane.addTab("Home", homeTabPanel);

    loadBtn.setBorder(javax.swing.BorderFactory.createTitledBorder("Backup"));

    jLabel3.setText("Backup clients_db xml in a location  :");

    saveButton.setText("Save...");
    saveButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        saveButtonActionPerformed(evt);
      }
    });

    jLabel4.setText("Load clients_db xml from a location :");

    loadButton.setText("Load...");
    loadButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        loadButtonActionPerformed(evt);
      }
    });

    javax.swing.GroupLayout loadBtnLayout = new javax.swing.GroupLayout(loadBtn);
    loadBtn.setLayout(loadBtnLayout);
    loadBtnLayout.setHorizontalGroup(
      loadBtnLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(loadBtnLayout.createSequentialGroup()
        .addContainerGap()
        .addGroup(loadBtnLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addGroup(loadBtnLayout.createSequentialGroup()
            .addComponent(jLabel3)
            .addGap(18, 18, 18)
            .addComponent(saveButton))
          .addGroup(loadBtnLayout.createSequentialGroup()
            .addComponent(jLabel4)
            .addGap(18, 18, 18)
            .addComponent(loadButton)))
        .addContainerGap(213, Short.MAX_VALUE))
    );
    loadBtnLayout.setVerticalGroup(
      loadBtnLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(loadBtnLayout.createSequentialGroup()
        .addContainerGap()
        .addGroup(loadBtnLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel3)
          .addComponent(saveButton))
        .addGap(18, 18, 18)
        .addGroup(loadBtnLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(jLabel4)
          .addComponent(loadButton))
        .addContainerGap())
    );

    javax.swing.GroupLayout settingsTabPanelLayout = new javax.swing.GroupLayout(settingsTabPanel);
    settingsTabPanel.setLayout(settingsTabPanelLayout);
    settingsTabPanelLayout.setHorizontalGroup(
      settingsTabPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(settingsTabPanelLayout.createSequentialGroup()
        .addContainerGap()
        .addComponent(loadBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        .addContainerGap())
    );
    settingsTabPanelLayout.setVerticalGroup(
      settingsTabPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(settingsTabPanelLayout.createSequentialGroup()
        .addContainerGap()
        .addComponent(loadBtn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addContainerGap(213, Short.MAX_VALUE))
    );

    serverTabbedPane.addTab("Backup", settingsTabPanel);

    jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder("Mail service"));

    protocolLbl.setText("Protocol :");

    MhostLbl.setText("Mail Host :");

    MuserLbl.setText("Mail User :");

    jLabel5.setText("Mail Pass :");

    protocolCbox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "SMTP" }));

    jLabel6.setText("Port :");

    jLabel7.setText("Email Address :");

    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
    jPanel1.setLayout(jPanel1Layout);
    jPanel1Layout.setHorizontalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
              .addComponent(protocolLbl)
              .addComponent(MhostLbl))
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(mailHostTxt, javax.swing.GroupLayout.DEFAULT_SIZE, 129, Short.MAX_VALUE)
              .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(protocolCbox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel6)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(mailPortTxt, javax.swing.GroupLayout.DEFAULT_SIZE, 43, Short.MAX_VALUE))))
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addComponent(MuserLbl)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(mailUserHost)))
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addGap(41, 41, 41)
            .addComponent(jLabel5)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(mailPassHost, javax.swing.GroupLayout.PREFERRED_SIZE, 129, javax.swing.GroupLayout.PREFERRED_SIZE))
          .addGroup(jPanel1Layout.createSequentialGroup()
            .addGap(18, 18, 18)
            .addComponent(jLabel7)
            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
            .addComponent(mailAddressTxt)))
        .addContainerGap(65, Short.MAX_VALUE))
    );
    jPanel1Layout.setVerticalGroup(
      jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(jPanel1Layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(protocolLbl)
          .addComponent(protocolCbox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(jLabel6)
          .addComponent(mailPortTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addGap(11, 11, 11)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(MhostLbl)
          .addComponent(mailHostTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(jLabel7)
          .addComponent(mailAddressTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(MuserLbl)
          .addComponent(mailUserHost, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(jLabel5)
          .addComponent(mailPassHost, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
    );

    javax.swing.GroupLayout settiingsPanelLayout = new javax.swing.GroupLayout(settiingsPanel);
    settiingsPanel.setLayout(settiingsPanelLayout);
    settiingsPanelLayout.setHorizontalGroup(
      settiingsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(settiingsPanelLayout.createSequentialGroup()
        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        .addContainerGap())
    );
    settiingsPanelLayout.setVerticalGroup(
      settiingsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(settiingsPanelLayout.createSequentialGroup()
        .addContainerGap()
        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addContainerGap(195, Short.MAX_VALUE))
    );

    serverTabbedPane.addTab("Settings", settiingsPanel);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addComponent(serverTabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 521, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addComponent(serverTabbedPane, javax.swing.GroupLayout.DEFAULT_SIZE, 365, Short.MAX_VALUE))
    );

    serverTabbedPane.getAccessibleContext().setAccessibleName("Home");

    pack();
  }// </editor-fold>//GEN-END:initComponents

    private void startServerBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startServerBtnActionPerformed

      /*If the GO! button was pressed*/
      if (this.startServerBtn.isSelected()) {
        //Server is started
        startOnce = true;

        //Change the text of the toggle button to STOP
        this.startServerBtn.setText("STOP!");

        /*Get the Hostname and Port*/
        String hostName = this.hostNameTxt.getText();

        /*Check is use non-local IP check box is selected*/
        if (this.publicIPbox.isSelected()) {
          /*Read IP*/
          String readIP = getPublicIPAddress();


          /*If there is an internet connection and IP is retrived from the website
           show popUp message*/
          if (! readIP.equals("ERROR")) {
           /*Change hostname textbox*/
           hostNameTxt.setText(readIP);

           /*Show popup*/
           createWarningDialog("Server is running on your Public IP Address.\n" +
            "\nClients must use IP : " + readIP + " & Port : " + hostPortTxt.getText() + " to connect. \n " +
            "\nMake sure OS and Rooter firewalls are not blocking ports 3830,3831");
          }
          else {
            createWarningDialog("Cannot retrieve Public IP Address.\n" +
              "\nServer started on Hostname: localhost & Port: " + hostPortTxt.getText() + " instead.");

          }//else
        }//end if

       try {

          /*Translate port to Integer*/
          int hostPort = Integer.parseInt(this.hostPortTxt.getText());

          /*Before starting the server: (1) Check if hostname and port
          are empty*/
         if (! hostName.equals("") && hostName != null && (hostPort>=0
             && hostPort<=65535)) {

           /*Create the server side of a client/server socket connection.*/
           /*This will throw an exceprion if hostport is not right*/
           serverSocket = new ServerSocket(hostPort);

           /*Start counting the uptime*/
           //Get time at start
           startTime = System.currentTimeMillis(); // time at start in millisecs

           //Call the UpTimeListener class every 1 second (1000 millisec)
           upTimeCounter = new javax.swing.Timer(1000, new UpTimeListener());
           upTimeCounter.start();

           /*logTextField component is responsible for displaying the messages*/
           logTextArea.append("\n ***************************");
           logTextArea.append(newLine + msg.init);
           logTextArea.append("\n Server is running on: "
                                    + serverSocket.getInetAddress().toString());
           logTextArea.append("\n Listening for requests on Port: " + hostPort);
           logTextArea.append("\n ***************************");

           /*****************************************************************
            * The accept method waits until a client starts up and requests
            * a connection on the host and port of this server. The accept
            * method will return a new Socket object for the server when the
            * when the connection is successfully established.
            */
           whileThread = new ServerAcceptThread(serverSocket,
                                                logTextArea,
                                                this);
           whileThread.start();
          
         }//end inner if (check if hostname and port in not null)
         else {
          /*Display warning to user*/
          createWarningDialog("Check hostname and port.");
         }
        }//end try
        catch (IOException e) {
           logTextArea.append("\n Could not listen on specified port. ");
           logTextArea.append("\n Port may be reserved. Try another port ");
           //System.exit(-1);
         }//end catch
        catch (Exception e) {
           logTextArea.append("\n Specify a port in range 0 - 65535");
         }//end catch
       }//end if
      else {
        try {
        /*************************
         * Reset everything.     *
         *************************/

        /*Set default hostname and port*/
        hostNameTxt.setText("localhost");
        hostPortTxt.setText("3830");

        /**
         * Before closing the server, save the list of users.
         * Access ClientHandler list, and then save it in xml.
         */
         writeXMLFile(this.fileName);

         /*Stop the thread*/
         whileThread.stop();

         /*Close serverSocket*/
         serverSocket.close();

         /*Change label text*/
         this.startServerBtn.setText("GO!");
         this.logTextArea.setText("");

         /*Stop counter and clear label*/
         upTimeCounter.stop();
         upTimeLbl.setText("0:00:00");

         /*Inform user that client_db files are saved*/
         createWarningDialog("Client's database saved. <clients_db.dat>");         
       }//try
        catch (Exception exe)
         {
           logTextArea.append("\n Could not listen on specified port. ");
           logTextArea.append("\n Port may be reserved. Try another port. ");
           logTextArea.append("\n XML file, clients_db maybe corrupted. ");
         }//catch
      }//end else
}//GEN-LAST:event_startServerBtnActionPerformed

    private void exitBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitBtnActionPerformed
      /*Call quit method the application will exit and all clients will
       be disconnected from the server*/
      quitMethod();
    }//GEN-LAST:event_exitBtnActionPerformed

    /***
     * Tab : Backup -> save
     *
     * When the user clicks the save button in the backup tab
     * call saveClients() method.
     *
     * @param evt
     */
    private void saveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveButtonActionPerformed
      if (this.startOnce)
       saveClients();
      else
       createWarningDialog("Server not started yet.");
    }//GEN-LAST:event_saveButtonActionPerformed

    /****
     * 
     * Tab: Backup -> Auto Backup option.
     * This option allows user to autobackup server client data. 
     * 
     * @param evt
     */
 /***
  * Tab : Backup -> Load...
  *
  * This is to load a clients_db file
  * @param evt
  */
    private void loadButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadButtonActionPerformed
     /*Call method to open clients db*/
     openClientsDB();
    }//GEN-LAST:event_loadButtonActionPerformed

 /********************************************************************
  * This method will be used to create a popUp menu each time an error
  * occurs.
  */
 private void createWarningDialog(String warn)
 {
   JOptionPane.showMessageDialog(this,"eLearningMaps - " + warn);
 }//end

 /*******************************************************************
  * This method will be called when the user wants to quit the
  * application
  */
 private void quitMethod()
  {
   //Setup msg appear to the dialog window
   String popUpMsg = " Do you want to terminate the server? " +
     "\n The server will stop, connected clients will" +
     " be disconnected.\nServer will automatically backup data."  ;

   int confirm = JOptionPane.showConfirmDialog
  	(null,popUpMsg,"eLearningMaps - Warning",JOptionPane.YES_NO_OPTION);

   //if yes button clicked exit
   if (confirm == JOptionPane.YES_OPTION)
    {
      /*Save Mail server setting for Password recovery*/
      writeMailServerFile();

       /**
       * Before closing the server, save the list of users.
       * Access ClientHandler list, and then save it in xml*/
       if (startOnce)
        writeXMLFile(this.fileName);

      //Exit application close all windows
      System.exit(0);
    }//end if
  }//end quit method


 /***
  * Method used by when checkbox "non-local IP" is selected. The method
  * is responsible of finding the local IP address of
  *
  * @return
  */
 public String getPublicIPAddress(){
  try {
   URL findIPUrl = new URL("http://www.whatismyip.com/automation/n09230945.asp");
   BufferedReader read = new BufferedReader( new InputStreamReader(findIPUrl.openStream()));

   /*Read IP Address*/
   String readIPAddress = (read.readLine()).trim();

   return readIPAddress;

  } catch (Exception exe) {
    System.out.println("ServerConsole - Cannot retreive IP address from URL.");
   return "ERROR";
  }//catch
 }//end method


/***
 * This method is used to store Mail Server details for
 * pass recover into a .dat file. Method is called when
 * application QUIT.
 */
public void writeMailServerFile()
 {
  try {
   /*Password string*/
    String mailPassTxt = new String(this.mailPassHost.getPassword());


   /*Check if boxes have something*/
   if (mailPortTxt.getText().equals("") || mailPortTxt.getText() == null) {
    mailPortTxt.setText("-1");
   }
   if (mailHostTxt.getText().equals("") || mailHostTxt.getText() == null) {
    mailHostTxt.setText("host");
   }
   if (mailAddressTxt.getText().equals("") || mailAddressTxt.getText() == null) {
    mailAddressTxt.setText("yourmail@domain");
   }
   if (mailUserHost.getText().equals("") || mailUserHost.getText() == null) {
    mailUserHost.setText("user");
   }
   if (mailPassTxt.equals("") || mailPassTxt == null) {
    mailPassTxt = "pass";
   }


   /*Start writing text file*/
   BufferedWriter out = new BufferedWriter(new FileWriter("email.dat"));

   //Protocol (store combo box index)
   out.write("" + this.protocolCbox.getSelectedIndex()+"?");
   out.newLine();
   //Port
   out.write("" + this.mailPortTxt.getText()+"?");
   out.newLine();
   //Host
   out.write(this.mailHostTxt.getText()+"?");
   out.newLine();
   //Email Address
   out.write("" + this.mailAddressTxt.getText()+"?");
   out.newLine();
   //Username
   out.write(this.mailUserHost.getText()+"?");
   out.newLine();

   /**
    * Case : Password 
    *   (1) Encrypt password
    *   (2) Then write to file
    */
   String encryptPassTxt = servEncytptMechanism.doEncryption(mailPassTxt);

   out.write(encryptPassTxt+"?");

   out.close();
  } catch (IOException e) {
    this.createWarningDialog("Cannot write mail server file.");
  }//catch
 }//end method


/***
 * This method read the mail.dat file. Details are restored
 * at the "Settings" Tab on the main ServerConsoleUI window.
 */
public void readMailServerFile()
 {
  try {
   /*Read the file*/
   BufferedReader in = new BufferedReader(new FileReader("email.dat"));

   String line = "";
   String outcome = "";

   while ((line = in.readLine()) != null)
    {
     outcome += line;
    }//end while

   /*Remove last "?"*/
   //outcome = outcome.substring(0, outcome.length()-1);

   /*Fill appropriate JTextFields with values from string outcome*/
   StringTokenizer requestTokens = new StringTokenizer(outcome, "?");

   //Protocol (store combo box index)
   protocolCbox.setSelectedIndex(Integer.parseInt(requestTokens.nextToken()));

   //Port
   mailPortTxt.setText(requestTokens.nextToken());

   //Host
   mailHostTxt.setText(requestTokens.nextToken());

   //Email Address
   mailAddressTxt.setText(requestTokens.nextToken());

   //Username
   mailUserHost.setText(requestTokens.nextToken());

    /**
    * Case : Password
    *   (1) Decrypt password
    *   (2) Then write to file
    */
    String decryptPassTxt = servEncytptMechanism.doDecrypt(requestTokens.nextToken());
    mailPassHost.setText(decryptPassTxt);
    //System.out.println("Decrypt is : " + decryptPassTxt);

   /*Close buffer*/
   in.close();
  } catch (IOException e) {
    this.createWarningDialog("Cannot read mail server file.");
  }//catch
}//end method


/***
 * This method returns all the details for the mail service.
 * Will be used for pass recovery
 * 
 * @return
 */
public String getMailDetails(){
  return mailPortTxt.getText()+"?" + mailHostTxt.getText()+"?" +
         mailAddressTxt.getText()+"?" + mailUserHost.getText()+"?" +
         new String(this.mailPassHost.getPassword())+"?";
         
}//end method

  /*******
   * 
   * @param arrayOfData
   * @param fileName
   */
  public void writeXMLFile(File fileName)
	{
     try {
	   /*Get the arraylist of ExistingClients*/
       List arrayOfData = this.getExistingClientsList();

       /*If arraylist not empty*/
       if (arrayOfData != null) {

        /*Wrap a FileWriter object*/
	    PrintWriter savefile = new PrintWriter(new FileWriter(fileName));

        /*Start creating xml document*/
        savefile.println("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>");

        /*Start document*/
	    savefile.println("<client-database>");

	    /*Loop through the array and Print xml for each shape*/
        for (int i=0; i<arrayOfData.size(); i++)
		 {
           //if (((ClientHandler) arrayOfData.get(i)).getUser() != null)
		   /*Call toStringXML method of each client*/
           //savefile.println(((ClientHandler) arrayOfData.get(i)).getUser().toStringXML());

           savefile.println( ((User) existingClientsList.get(i)).toStringXML());
		 }//end for array

		 /*Close xml document*/
         savefile.println("</client-database>");

		 /*Close file*/
		 savefile.close();
       }//end if
      }//try
	 catch (Exception e)
	  {
       createWarningDialog("XML file error");
       e.printStackTrace();
	  }//end catch
	}//end write xml


 /***
  * Tab: Backup -> Save...
  *
  * This method will be called when the user requires to backup
  * the clients database to a different location to the default.
  * 
  */
 public void saveClients()
  {
   JFileChooser fileChooser = new JFileChooser();

   /*Add custom filter for files*/
   fileChooser.addChoosableFileFilter(new ServerConsoleFilter());

   /*Show save dialog*/
   int returnVal = fileChooser.showSaveDialog(this);

  /*If save button is clicked*/
  if(returnVal == JFileChooser.APPROVE_OPTION) {
   try
    {
    /**
     * Call mehtod to store file into specific location
     */
    String filePath = "";

    /**
     * Check if the filename has .svg appended at the end
     **/
     if (fileChooser.getSelectedFile().getName().matches(".*\\.dat"))
      {
       filePath = fileChooser.getSelectedFile().getPath();
      }//end if
     else /*if .dat is not appened.Then add it at the end*/
      {
       filePath = fileChooser.getSelectedFile().getPath()+".dat";
      }//end else

      /*Create the new file*/
      File fileToSave = new File(filePath);

      /*Check if the file already exists*/
      if (fileToSave.exists())
       {
        int confirm = JOptionPane.showConfirmDialog
	   (null,"The filename '"+filePath+"' already exists." +
             "\nDo you want to replace it?",
                        "eLearningMaps - Option Confirm",
                        JOptionPane.YES_NO_OPTION,
                        JOptionPane.WARNING_MESSAGE);
	   //if yes button clicked exit
	   if (confirm == JOptionPane.YES_OPTION)
	   {
        /***
         * This means that the user wants to override the selected
         * file. Firstly delete the file
         ***/
         writeXMLFile(fileToSave);
	   }//end if
      }//end if file to save exists
     else
      {
       writeXMLFile(fileToSave);
      }//end if file does not exist
    }//end try
   catch (Exception exe) {
    createWarningDialog("Cannot write backup file.");
    }//end catch
  }//end if
}//end method


/****
 * This method will be called when the user wants to load
 * a prevously saved database of clients.
 * clients_db.dat
 */
public void openClientsDB()
 {
  JFileChooser fileChooser = new JFileChooser();

  /*Add the .dat filter*/
  fileChooser.addChoosableFileFilter(new ServerConsoleFilter());

  /*Popup a filechooser dialog*/
  int returnVal = fileChooser.showOpenDialog(this);

  /*If save button is clicked*/
  if(returnVal == JFileChooser.APPROVE_OPTION) {
   try
   {
    /**
    * Call mehtod to store file into specific location
    */
    String filePath = "";

    /**
     * Check if the filename has .cad appended at the end
     **/
     if (fileChooser.getSelectedFile().getName().matches(".*\\.dat"))
      {
       //Get the file path
       filePath = fileChooser.getSelectedFile().getPath();

       //Create a new File 
	   File fileToSave = new File(filePath);

       //Call the method to update the file
       this.file_reader.setFile(fileToSave);

       //Read the file by calling readClientsXML()
       this.file_reader.readClientsXML();

       //Finally get the List created
       existingClientsList = file_reader.getExistingClientsList();
      }//end if
	 }//try
	 catch (Exception exe)
	  {
	   this.createWarningDialog("Error IO - while openning file.");
       exe.printStackTrace();
	 }//catch
   }//end
 }//end method

 /****
  * Synchronized method to return the list of existing clients
  * to the service
  *
  * @return
  */
 public synchronized List getExistingClientsList() {
  return this.existingClientsList;
 }//end

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JLabel MhostLbl;
  private javax.swing.JLabel MuserLbl;
  private javax.swing.JButton exitBtn;
  private javax.swing.JPanel homeTabPanel;
  private javax.swing.JTextField hostNameTxt;
  private javax.swing.JLabel hostPortLbl;
  private javax.swing.JTextField hostPortTxt;
  private javax.swing.JLabel jLabel1;
  private javax.swing.JLabel jLabel2;
  private javax.swing.JLabel jLabel3;
  private javax.swing.JLabel jLabel4;
  private javax.swing.JLabel jLabel5;
  private javax.swing.JLabel jLabel6;
  private javax.swing.JLabel jLabel7;
  private javax.swing.JPanel jPanel1;
  private javax.swing.JPanel jPanel2;
  private javax.swing.JScrollPane jScrollPane1;
  private javax.swing.JPanel loadBtn;
  private javax.swing.JButton loadButton;
  private javax.swing.JTextArea logTextArea;
  private javax.swing.JTextField mailAddressTxt;
  private javax.swing.JTextField mailHostTxt;
  private javax.swing.JPasswordField mailPassHost;
  private javax.swing.JTextField mailPortTxt;
  private javax.swing.JTextField mailUserHost;
  private javax.swing.JComboBox protocolCbox;
  private javax.swing.JLabel protocolLbl;
  private javax.swing.JCheckBox publicIPbox;
  private javax.swing.JButton saveButton;
  private javax.swing.JButton saveLogBtn;
  private javax.swing.JLabel serverNameLbl;
  private javax.swing.JTabbedPane serverTabbedPane;
  private javax.swing.JPanel settiingsPanel;
  private javax.swing.JPanel settingsTabPanel;
  private javax.swing.JToggleButton startServerBtn;
  private javax.swing.JLabel upTimeLbl;
  // End of variables declaration//GEN-END:variables


  /*********************************************************************
  * INNER CLASS: This is an inner class to count the Uptime of the
  * server. This inner class will be called each second to update the
  * label.
  */
 class UpTimeListener extends Thread implements ActionListener {

   public void actionPerformed(ActionEvent e) {
     //Get the timer
     int currentTime=(int)(System.currentTimeMillis()-startTime);

     //Update the label
     upTimeLbl.setText("" + timeAsStringShort(currentTime));
   }//end actionPerformed

   /*****************************************************************
    * This method is used to convert miliseconds to actual format
    * h:m:s. Returns the value back and then
    */
    public String timeAsStringShort(long milliSec) {
      int hours = Math.abs((int) milliSec / 3600000);
      int minutes = Math.abs((int) (milliSec % 3600000) / 60000);
      int seconds = Math.abs((int) (milliSec % 60000) / 1000);

      String str = hours + ":";
      str += ((minutes < 10) ? ("0" + minutes) : String.valueOf(minutes));
      str += ":";
      str += ((seconds < 10) ? ("0" + seconds) : String.valueOf(seconds));

      if (milliSec < 0) str = "-" + str;

    //Return the string
    return str;
  }//end method
 }//end UpTimeListener inner class


/*******************************************************************
* This is an inner class extending FileFilter for use in
* JFileChooser (DAT). .dat file backup server data.
*
* @author Klitos Christodoulou
*/
class ServerConsoleFilter extends javax.swing.filechooser.FileFilter
{
  public boolean accept(File file)
  {
      return file.isDirectory() || file.getName().toLowerCase().endsWith(".dat");
  }//end file

  public String getDescription()
  {
      return ".dat clientdb files";
  }//end inner class DATfilter
}//end inner class DATfilter
}//end ServerConsoleUI class
